문제
-------------
N 개의 막대 기둥이 일렬로 세워져 있다. 기둥들의 폭은 모두 1 m이며 높이는 다를 수 있다. 
이 기둥들을 이용하여 양철로 된 창고를 제작하려고 한다. 창고에는 모든 기둥이 들어간다. 이 창고의 지붕을 다음과 같이 만든다.

1. 지붕은 수평 부분과 수직 부분으로 구성되며, 모두 연결되어야 한다.
2. 지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다.
3. 지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다.
4. 지붕의 가장자리는 땅에 닿아야 한다.

비가 올 때 물이 고이지 않도록 지붕의 어떤 부분도 오목하게 들어간 부분이 없어야 한다.
그림 1은 창고를 옆에서 본 모습을 그린 것이다. 이 그림에서 굵은 선으로 표시된 부분이 지붕에 해당되고, 
지붕과 땅으로 둘러싸인 다각형이 창고를 옆에서 본 모습이다. 이 다각형을 창고 다각형이라고 하자.

창고 주인은 창고 다각형의 면적이 가장 작은 창고를 만들기를 원한다. 
기둥들의 위치와 높이가 주어질 때, 가장 작은 창고 다각형의 면적을 구하는 프로그램을 작성하시오.

입력
-------------
첫 줄에는 기둥의 개수를 나타내는 정수 N이 주어진다. N은 1 이상 1,000 이하이다. 
그 다음 N 개의 줄에는 각 줄에 각 기둥의 왼쪽 면의 위치를 나타내는 정수 L과 높이를 나타내는 정수 H가 한 개의 빈 칸을 사이에 두고 주어진다. L과 H는 둘 다 1 이상 1,000 이하이다.

출력
-------------
첫 줄에 창고 다각형의 면적을 나타내는 정수를 출력한다.

풀이
-------------
* 창고의 인덱스기준으로 입력값을 정렬하여 계산을 편하게 한다.
* 가장 높이가 큰 인덱스를잡아 max로 설정한다.
* 초기 값 0으로 최초 인덱스부터 max 까지 진행, 현재 값보다 높은 지점이 나왔을때, 현재값x(현재 인덱스 - 직전 인덱스)의 값을 더한다.
* max까지 도달한 후, 이번에는 가장 끝의 인덱스부터 max까지 거꾸로 진행하여 똑같은 계산은 다시 수행한다.
* 여기서 나온 모든 직사각형의 합이 결과값이다.

***

코드
-------------

```java

import java.util.*;
import java.io.*;

class tower implements Comparable<tower> {
	int point;
	int height;

	tower() {
		this(0, 0);
	}

	tower(int point, int height) {
		this.point = point;
		this.height = height;
	}

	@Override
	public int compareTo(tower o) {
		// TODO Auto-generated method stub
		return point - o.point;
	}
}

public class Main {

	public static void main(String[] args) throws Exception {
		BufferedReader bf = new BufferedReader(new InputStreamReader(new FileInputStream("res/input_bj_2304.txt")));
		// BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));

		int T = Integer.parseInt(bf.readLine());
		for (int test_case = 1; test_case <= T; test_case++) {

			int N = Integer.parseInt(bf.readLine());
			tower[] t = new tower[N];
			int big_point = 0;
			int max = -1;
			for (int i = 0; i < N; i++) {
				StringTokenizer st = new StringTokenizer(bf.readLine());
				int point = Integer.parseInt(st.nextToken());
				int height = Integer.parseInt(st.nextToken());
				if (max < height)
				{
					max = height; // 타워의 높이
					big_point = point; // 타워의 가장 높은 크기의 인덱스
				}
				t[i] = new tower(point, height); // 배열에 저장
			}
			Arrays.sort(t);
			max = 0;
			int sum = 0;
			int befpoint = 0;
			
			for (int i = 0; i < N; i++) {
					if (max <= t[i].height) {
						sum += max * (t[i].point - befpoint);
						max = t[i].height;
						befpoint = t[i].point;
					}
					if (t[i].point == big_point)
					{
						sum +=t[i].height;
						break;
					}
				 
			}
			max = 0;
			befpoint = 1000;
			for(int i = N-1;i>=0;i--)
			{
				if (max <= t[i].height) {
					sum += max * (befpoint-t[i].point);
					max = t[i].height;
					befpoint = t[i].point;
				}
				if (t[i].point == big_point)
				{
					break;
				}
			}
			System.out.println(sum);
		}
	}

}
